package advent.year2024.day21

import advent.meta.readInput
import advent.utils.Point
import advent.utils.next

/**
 * --- Day 22: Monkey Market ---
 * As you're all teleported deep into the jungle, a monkey steals The Historians' device! You'll need to get it back
 * while The Historians are looking for the Chief.
 * The monkey that stole the device seems willing to trade it, but only in exchange for an absurd number of bananas.
 * Your only option is to buy bananas on the Monkey Exchange Market.
 * You aren't sure how the Monkey Exchange Market works, but one of The Historians senses trouble and comes over to
 * help. Apparently, they've been studying these monkeys for a while and have deciphered their secrets.
 * Today, the Market is full of monkeys buying good hiding spots. Fortunately, because of the time you recently spent
 * in this jungle, you know lots of good hiding spots you can sell! If you sell enough hiding spots, you should be able
 * to get enough bananas to buy the device back.
 * On the Market, the buyers seem to use random prices, but their prices are actually only pseudorandom! If you know
 * the secret of how they pick their prices, you can wait for the perfect time to sell.
 * The part about secrets is literal, the Historian explains. Each buyer produces a pseudorandom sequence of secret
 * numbers where each secret is derived from the previous.
 * In particular, each buyer's secret number evolves into the next secret number in the sequence via the following
 * process:
 *
 * Calculate the result of multiplying the secret number by 64. Then, mix this result into the secret number. Finally,
 * prune the secret number.
 * Calculate the result of dividing the secret number by 32. Round the result down to the nearest integer. Then, mix
 * this result into the secret number. Finally, prune the secret number.
 * Calculate the result of multiplying the secret number by 2048. Then, mix this result into the secret number.
 * Finally, prune the secret number.
 *
 * Each step of the above process involves mixing and pruning:
 *
 * To mix a value into the secret number, calculate the bitwise XOR of the given value and the secret number. Then, the
 * secret number becomes the result of that operation. (If the secret number is 42 and you were to mix 15 into the
 * secret number, the secret number would become 37.)
 * To prune the secret number, calculate the value of the secret number modulo 16777216. Then, the secret number
 * becomes the result of that operation. (If the secret number is 100000000 and you were to prune the secret number,
 * the secret number would become 16113920.)
 *
 * After this process completes, the buyer is left with the next secret number in the sequence. The buyer can repeat
 * this process as many times as necessary to produce more secret numbers.
 * So, if a buyer had a secret number of 123, that buyer's next ten secret numbers would be:
 * 15887950
 * 16495136
 * 527345
 * 704524
 * 1553684
 * 12683156
 * 11100544
 * 12249484
 * 7753432
 * 5908254
 *
 * Each buyer uses their own secret number when choosing their price, so it's important to be able to predict the
 * sequence of secret numbers for each buyer. Fortunately, the Historian's research has uncovered the initial secret
 * number of each buyer (your puzzle input). For example:
 * 1
 * 10
 * 100
 * 2024
 *
 * This list describes the initial secret number of four different secret-hiding-spot-buyers on the Monkey Exchange
 * Market. If you can simulate secret numbers from each buyer, you'll be able to predict all of their future prices.
 * In a single day, buyers each have time to generate 2000 new secret numbers. In this example, for each buyer, their
 * initial secret number and the 2000th new secret number they would generate are:
 * 1: 8685429
 * 10: 4700978
 * 100: 15273692
 * 2024: 8667524
 *
 * Adding up the 2000th new secret number for each buyer produces 37327623.
 * For each buyer, simulate the creation of 2000 new secret numbers. What is the sum of the 2000th secret number
 * generated by each buyer?
 *
 */
class RobotKeypads(private val codes: List<String>) {
    constructor(input: String) : this(input.trim().lines())

    private fun numericToPoint(numeric: Char): Point = when (numeric) {
        'A' -> Point(2, 0)
        '0' -> Point(1, 0)
        '1' -> Point(0, 1)
        '2' -> Point(1, 1)
        '3' -> Point(2, 1)
        '4' -> Point(0, 2)
        '5' -> Point(1, 2)
        '6' -> Point(2, 2)
        '7' -> Point(0, 3)
        '8' -> Point(1, 3)
        '9' -> Point(2, 3)
        else -> throw IllegalArgumentException("Unrecognized button $numeric")
    }

    private fun numericToShortestDirections(transition: Pair<Char, Char>): String {
        val (fromButton, toButton) = transition
        val from = numericToPoint(fromButton)
        val to = numericToPoint(toButton)
        val crossingTheEmptyPoint = (from.x == 0 && to.y == 0) || (from.y == 0 && to.x == 0)
        val delta = to - from
        // We try to prefer
        // LEFT UP to UP LEFT
        // LEFT DOWN to DOWN LEFT
        // RIGHT UP to UP RIGHT
        // DOWN RIGHT to RIGHT DOWN
        // unless crossing the empty point, in which case we minimize the amount of "turns", i.e., we keep all the same
        // symbol together.
        val movementPart = if (crossingTheEmptyPoint) {
            if (delta.x > 0) {
                ">".repeat(delta.x) + "v".repeat(-delta.y)
            } else {
                "^".repeat(delta.y) + "<".repeat(-delta.x)
            }
        } else {
            when {
                delta.x <= 0 && delta.y <= 0 -> "<".repeat(-delta.x) + "v".repeat(-delta.y)
                delta.x <= 0 && delta.y > 0 -> "<".repeat(-delta.x) + "^".repeat(delta.y)
                delta.x > 0 && delta.y <= 0 -> "v".repeat(-delta.y) + ">".repeat(delta.x)
                else -> "^".repeat(delta.y) + ">".repeat(delta.x)
            }
        }
        return movementPart + "A"
    }

    // Returns a string representing the direction keypad inputs
    private fun expandNumericPad(numeric: String): String {
        val steps: List<Pair<Char, Char>> = ("A$numeric").zipWithNext()
        return steps.joinToString(separator = "") { numericToShortestDirections(it) }
    }

    private fun expandDirectionPad(countsByDirectionSeries: Map<String, Long>): Map<String, Long> {
        val output = mutableMapOf<String, Long>()
        countsByDirectionSeries.entries.forEach { (countsByDirectionSeries, count) ->
            val newSteps = expandDirectionSeries(countsByDirectionSeries)
            newSteps.forEach { output.merge(it, count, Long::plus) }
        }
        return output
    }

    private fun expandDirectionSeries(directionSeries: String): List<String> {
        val steps = ("A$directionSeries").zipWithNext()
        return steps.map { directionToShortestDirections(it) }
    }

    private fun directionToShortestDirections(transition: Pair<Char, Char>): String {
        val movement = when (transition) {
            '<' to '<' -> ""
            '<' to 'v' -> ">"
            '<' to '>' -> ">>"
            '<' to '^' -> ">^"
            '<' to 'A' -> ">>^"
            '^' to '^' -> ""
            '^' to 'A' -> ">"
            '^' to '<' -> "v<"
            '^' to 'v' -> "v"
            '^' to '>' -> "v>"
            'A' to '^' -> "<"
            'A' to 'A' -> ""
            'A' to '<' -> "v<<"
            'A' to 'v' -> "<v"
            'A' to '>' -> "v"
            'v' to '^' -> "^"
            'v' to 'A' -> "^>"
            'v' to '<' -> "<"
            'v' to 'v' -> ""
            'v' to '>' -> ">"
            '>' to '^' -> "<^"
            '>' to 'A' -> "^"
            '>' to '<' -> "<<"
            '>' to 'v' -> "<"
            '>' to '>' -> ""
            else -> throw IllegalArgumentException("Unrecognized transition $transition")
        }
        return movement + "A"
    }

    fun complexitySum(numBots: Int = 2): Long = codes.sumOf { it.complexity(numBots) }

    private fun String.complexity(numBots: Int) = lengthOfShortestSequence(this, numBots) *
            this.numericPart()

    private fun Map<String, Long>.sequenceLength() = entries.sumOf { (string, count) -> string.length * count }

    fun lengthOfShortestSequence(numeric: String, numBots: Int = 2) =
        mapOf(expandNumericPad(numeric) to 1L)
            .next(numBots, ::expandDirectionPad)
            .sequenceLength()

    private fun String.numericPart() = this.dropLastWhile { !it.isDigit() }.toInt()
}


// The only decisions to be made when pressing keys is, when our target requires both
// X-axis and Y-axis, presses, in which order to press - e.g., left then up, vs up then left.
// It feels like maybe there is a heuristic we can use where we always prefer one order over the other.
// The left button is one more step away from the A button than the other directions, so that
// seems like an asymmetry.
// To check in on this, we take the sample shortest sequences, and see which orderings appear there.
// (It's possible there might be ties, and Eric might have thrown in a tricky little "wrong order" that didn't
// matter, but it's worth checking in on.)
//
// In practice this reports:
//
// <^: 10 vs ^<: 0
// <v: 23 vs v<: 12
// >^: 23 vs ^>: 0
// >v: 0 vs v>: 0
// So, we clearly want LEFT before UP and RIGHT before UP.
// Our example has nothing to compare right vs down!
// That kind of makes sense if we never have an UP-RIGHT since that is the only way to find ourselves
// needing to do both right and down, at least when controlling another robot and not the original keypad.
// Probably we want to do DOWN before RIGHT, because then the controlling robot will have to make fewer moves
// (down right is down, left, a, right, a, up, a =)
// So that means we always try to prefer:
// LEFT UP to UP LEFT
// LEFT DOWN to DOWN LEFT
// RIGHT UP to UP RIGHT
// DOWN RIGHT to RIGHT DOWN

private fun investigateOrder() {
    val sequenceText = """
        029A: <vA<AA>>^AvAA<^A>A<v<A>>^AvA^A<vA>^A<v<A>^A>AAvA^A<v<A>A>^AAAvA<^A>A
        980A: <v<A>>^AAAvA^A<vA<AA>>^AvAA<^A>A<v<A>A>^AAAvA<^A>A<vA>^A<A>A
        179A: <v<A>>^A<vA<A>>^AAvAA<^A>A<v<A>>^AAvA^A<vA>^AA<A>A<v<A>A>^AAAvA<^A>A
        456A: <v<A>>^AA<vA<A>>^AAvAA<^A>A<vA>^A<A>A<vA>^A<A>A<v<A>A>^AAvA<^A>A
        379A: <v<A>>^AvA^A<vA<AA>>^AAvA<^A>AAvA^A<vA>^AA<A>A<v<A>A>^AAAvA<^A>A
    """.trimIndent()

    sequenceText.reportCounts("<^", "^<")
    sequenceText.reportCounts("<v", "v<")
    sequenceText.reportCounts(">^", "^>")
    sequenceText.reportCounts(">v", "v>")
}

private fun String.reportCounts(first: String, second: String) {
    fun String.count(substring: String) = this.split(substring).size - 1
    println("$first: ${this.count(first)} vs $second: ${this.count(second)}")
}

fun main() {
    investigateOrder()

    val keypads = RobotKeypads(readInput())

    println(keypads.complexitySum())
    println(keypads.complexitySum(25))
}